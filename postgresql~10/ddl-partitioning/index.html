
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Table Partitioning - PostgreSQL 10 - W3cubDocs</title>
  
  <meta name="description" content=" PostgreSQL supports basic table partitioning. This section describes why and how to implement partitioning as part of your database design. ">
  <meta name="keywords" content="table, partitioning, -, postgresql, postgresql~10">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/postgresql~10/ddl-partitioning/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/postgresql~10.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/postgresql~10/" class="_nav-link" title="" style="margin-left:0;">PostgreSQL 10</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _postgres">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1>5.10. Table Partitioning</h1>    <div class="toc"> <dl class="toc"> <dt><a href="../ddl-partitioning/#DDL-PARTITIONING-OVERVIEW">5.10.1. Overview</a></dt> <dt><a href="../ddl-partitioning/#DDL-PARTITIONING-DECLARATIVE">5.10.2. Declarative Partitioning</a></dt> <dt><a href="../ddl-partitioning/#DDL-PARTITIONING-IMPLEMENTATION-INHERITANCE"> 5.10.3. Implementation Using Inheritance</a></dt> <dt><a href="../ddl-partitioning/#DDL-PARTITIONING-CONSTRAINT-EXCLUSION">5.10.4. Partitioning and Constraint Exclusion</a></dt> </dl> </div>  <p>PostgreSQL supports basic table partitioning. This section describes why and how to implement partitioning as part of your database design.</p> <div class="sect2" id="DDL-PARTITIONING-OVERVIEW">    <h2 class="title">5.10.1. Overview</h2>    <p>Partitioning refers to splitting what is logically one large table into smaller physical pieces. Partitioning can provide several benefits:</p>  <ul> <li> <p>Query performance can be improved dramatically in certain situations, particularly when most of the heavily accessed rows of the table are in a single partition or a small number of partitions. The partitioning substitutes for leading columns of indexes, reducing index size and making it more likely that the heavily-used parts of the indexes fit in memory.</p> </li> <li> <p>When queries or updates access a large percentage of a single partition, performance can be improved by taking advantage of sequential scan of that partition instead of using an index and random access reads scattered across the whole table.</p> </li> <li> <p>Bulk loads and deletes can be accomplished by adding or removing partitions, if that requirement is planned into the partitioning design. Doing <code class="command">ALTER TABLE DETACH PARTITION</code> or dropping an individual partition using <code class="command">DROP TABLE</code> is far faster than a bulk operation. These commands also entirely avoid the <code class="command">VACUUM</code> overhead caused by a bulk <code class="command">DELETE</code>.</p> </li> <li> <p>Seldom-used data can be migrated to cheaper and slower storage media.</p> </li> </ul>  <p>The benefits will normally be worthwhile only when a table would otherwise be very large. The exact point at which a table will benefit from partitioning depends on the application, although a rule of thumb is that the size of the table should exceed the physical memory of the database server.</p> <p>PostgreSQL offers built-in support for the following forms of partitioning:</p> <div class="variablelist"> <dl class="variablelist"> <dt>Range Partitioning</dt> <dd> <p>The table is partitioned into <span class="quote">“<span class="quote">ranges</span>”</span> defined by a key column or set of columns, with no overlap between the ranges of values assigned to different partitions. For example, one might partition by date ranges, or by ranges of identifiers for particular business objects.</p> </dd> <dt>List Partitioning</dt> <dd> <p>The table is partitioned by explicitly listing which key values appear in each partition.</p> </dd> </dl> </div> <p>If your application needs to use other forms of partitioning not listed above, alternative methods such as inheritance and <code class="literal">UNION ALL</code> views can be used instead. Such methods offer flexibility but do not have some of the performance benefits of built-in declarative partitioning.</p> </div> <div class="sect2" id="DDL-PARTITIONING-DECLARATIVE">    <h2 class="title">5.10.2. Declarative Partitioning</h2>    <p>PostgreSQL offers a way to specify how to divide a table into pieces called partitions. The table that is divided is referred to as a <em class="firstterm">partitioned table</em>. The specification consists of the <em class="firstterm">partitioning method</em> and a list of columns or expressions to be used as the <em class="firstterm">partition key</em>.</p> <p>All rows inserted into a partitioned table will be routed to one of the <em class="firstterm">partitions</em> based on the value of the partition key. Each partition has a subset of the data defined by its <em class="firstterm">partition bounds</em>. Currently supported partitioning methods include range and list, where each partition is assigned a range of keys and a list of keys, respectively.</p> <p>Partitions may themselves be defined as partitioned tables, using what is called <em class="firstterm">sub-partitioning</em>. Partitions may have their own indexes, constraints and default values, distinct from those of other partitions. Indexes must be created separately for each partition. See <a class="xref" href="../sql-createtable/" title="CREATE TABLE">CREATE TABLE</a> for more details on creating partitioned tables and partitions.</p> <p>It is not possible to turn a regular table into a partitioned table or vice versa. However, it is possible to add a regular or partitioned table containing data as a partition of a partitioned table, or remove a partition from a partitioned table turning it into a standalone table; see <a class="xref" href="../sql-altertable/" title="ALTER TABLE">ALTER TABLE</a> to learn more about the <code class="command">ATTACH PARTITION</code> and <code class="command">DETACH PARTITION</code> sub-commands.</p> <p>Individual partitions are linked to the partitioned table with inheritance behind-the-scenes; however, it is not possible to use some of the inheritance features discussed in the previous section with partitioned tables and partitions. For example, a partition cannot have any parents other than the partitioned table it is a partition of, nor can a regular table inherit from a partitioned table making the latter its parent. That means partitioned tables and partitions do not participate in inheritance with regular tables. Since a partition hierarchy consisting of the partitioned table and its partitions is still an inheritance hierarchy, all the normal rules of inheritance apply as described in <a class="xref" href="../ddl-inherit/" title="5.9. Inheritance">Section 5.9</a> with some exceptions, most notably:</p>  <ul> <li> <p>Both <code class="literal">CHECK</code> and <code class="literal">NOT NULL</code> constraints of a partitioned table are always inherited by all its partitions. <code class="literal">CHECK</code> constraints that are marked <code class="literal">NO INHERIT</code> are not allowed to be created on partitioned tables.</p> </li> <li> <p>Using <code class="literal">ONLY</code> to add or drop a constraint on only the partitioned table is supported when there are no partitions. Once partitions exist, using <code class="literal">ONLY</code> will result in an error as adding or dropping constraints on only the partitioned table, when partitions exist, is not supported. Instead, constraints can be added or dropped, when they are not present in the parent table, directly on the partitions. As a partitioned table does not have any data directly, attempts to use <code class="command">TRUNCATE</code> <code class="literal">ONLY</code> on a partitioned table will always return an error.</p> </li> <li> <p>Partitions cannot have columns that are not present in the parent. It is neither possible to specify columns when creating partitions with <code class="command">CREATE TABLE</code> nor is it possible to add columns to partitions after-the-fact using <code class="command">ALTER TABLE</code>. Tables may be added as a partition with <code class="command">ALTER TABLE ... ATTACH PARTITION</code> only if their columns exactly match the parent, including any <code class="literal">oid</code> column.</p> </li> <li> <p>You cannot drop the <code class="literal">NOT NULL</code> constraint on a partition's column if the constraint is present in the parent table.</p> </li> </ul>  <p>Partitions can also be foreign tables (see <a class="xref" href="../sql-createforeigntable/" title="CREATE FOREIGN TABLE">CREATE FOREIGN TABLE</a>), although these have some limitations that normal tables do not. For example, data inserted into the partitioned table is not routed to foreign table partitions.</p> <div class="sect3" id="DDL-PARTITIONING-DECLARATIVE-EXAMPLE">    <h3 class="title">5.10.2.1. Example</h3>    <p>Suppose we are constructing a database for a large ice cream company. The company measures peak temperatures every day as well as ice cream sales in each region. Conceptually, we want a table like:</p> <pre data-language="sql">CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
);</pre> <p>We know that most queries will access just the last week's, month's or quarter's data, since the main use of this table will be to prepare online reports for management. To reduce the amount of old data that needs to be stored, we decide to only keep the most recent 3 years worth of data. At the beginning of each month we will remove the oldest month's data. In this situation we can use partitioning to help us meet all of our different requirements for the measurements table.</p> <p>To use declarative partitioning in this case, use the following steps:</p> <div class="orderedlist"> <ol class="orderedlist compact" type="1"> <li> <p>Create <code class="structname">measurement</code> table as a partitioned table by specifying the <code class="literal">PARTITION BY</code> clause, which includes the partitioning method (<code class="literal">RANGE</code> in this case) and the list of column(s) to use as the partition key.</p> <pre data-language="sql">CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);</pre> <p>You may decide to use multiple columns in the partition key for range partitioning, if desired. Of course, this will often result in a larger number of partitions, each of which is individually smaller. On the other hand, using fewer columns may lead to a coarser-grained partitioning criteria with smaller number of partitions. A query accessing the partitioned table will have to scan fewer partitions if the conditions involve some or all of these columns. For example, consider a table range partitioned using columns <code class="structfield">lastname</code> and <code class="structfield">firstname</code> (in that order) as the partition key.</p> </li> <li> <p>Create partitions. Each partition's definition must specify the bounds that correspond to the partitioning method and partition key of the parent. Note that specifying bounds such that the new partition's values will overlap with those in one or more existing partitions will cause an error. Inserting data into the parent table that does not map to one of the existing partitions will cause an error; an appropriate partition must be added manually.</p> <p>Partitions thus created are in every way normal PostgreSQL tables (or, possibly, foreign tables). It is possible to specify a tablespace and storage parameters for each partition separately.</p> <p>It is not necessary to create table constraints describing partition boundary condition for partitions. Instead, partition constraints are generated implicitly from the partition bound specification whenever there is need to refer to them.</p> <pre data-language="sql">
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

CREATE TABLE measurement_y2006m03 PARTITION OF measurement
    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01');

...
CREATE TABLE measurement_y2007m11 PARTITION OF measurement
    FOR VALUES FROM ('2007-11-01') TO ('2007-12-01');

CREATE TABLE measurement_y2007m12 PARTITION OF measurement
    FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')
    TABLESPACE fasttablespace;

CREATE TABLE measurement_y2008m01 PARTITION OF measurement
    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')
    WITH (parallel_workers = 4)
    TABLESPACE fasttablespace;</pre> <p>To implement sub-partitioning, specify the <code class="literal">PARTITION BY</code> clause in the commands used to create individual partitions, for example:</p> <pre data-language="sql">
CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')
    PARTITION BY RANGE (peaktemp);</pre> <p>After creating partitions of <code class="structname">measurement_y2006m02</code>, any data inserted into <code class="structname">measurement</code> that is mapped to <code class="structname">measurement_y2006m02</code> (or data that is directly inserted into <code class="structname">measurement_y2006m02</code>, provided it satisfies its partition constraint) will be further redirected to one of its partitions based on the <code class="structfield">peaktemp</code> column. The partition key specified may overlap with the parent's partition key, although care should be taken when specifying the bounds of a sub-partition such that the set of data it accepts constitutes a subset of what the partition's own bounds allows; the system does not try to check whether that's really the case.</p> </li> <li> <p>Create an index on the key column(s), as well as any other indexes you might want for every partition. (The key index is not strictly necessary, but in most scenarios it is helpful. If you intend the key values to be unique then you should always create a unique or primary-key constraint for each partition.)</p> <pre data-language="sql">
CREATE INDEX ON measurement_y2006m02 (logdate);
CREATE INDEX ON measurement_y2006m03 (logdate);
...
CREATE INDEX ON measurement_y2007m11 (logdate);
CREATE INDEX ON measurement_y2007m12 (logdate);
CREATE INDEX ON measurement_y2008m01 (logdate);</pre>
</li> <li> <p>Ensure that the <a class="xref" href="../runtime-config-query/#GUC-CONSTRAINT-EXCLUSION">constraint_exclusion</a> configuration parameter is not disabled in <code class="filename">postgresql.conf</code>. If it is, queries will not be optimized as desired.</p> </li> </ol> </div> <p>In the above example we would be creating a new partition each month, so it might be wise to write a script that generates the required DDL automatically.</p> </div> <div class="sect3" id="DDL-PARTITIONING-DECLARATIVE-MAINTENANCE">    <h3 class="title">5.10.2.2. Partition Maintenance</h3>    <p>Normally the set of partitions established when initially defining the table are not intended to remain static. It is common to want to remove old partitions of data and periodically add new partitions for new data. One of the most important advantages of partitioning is precisely that it allows this otherwise painful task to be executed nearly instantaneously by manipulating the partition structure, rather than physically moving large amounts of data around.</p> <p>The simplest option for removing old data is to drop the partition that is no longer necessary:</p> <pre data-language="sql">DROP TABLE measurement_y2006m02;</pre> <p>This can very quickly delete millions of records because it doesn't have to individually delete every record. Note however that the above command requires taking an <code class="literal">ACCESS EXCLUSIVE</code> lock on the parent table.</p> <p>Another option that is often preferable is to remove the partition from the partitioned table but retain access to it as a table in its own right:</p> <pre data-language="sql">
ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;</pre> <p>This allows further operations to be performed on the data before it is dropped. For example, this is often a useful time to back up the data using <code class="command">COPY</code>, pg_dump, or similar tools. It might also be a useful time to aggregate data into smaller formats, perform other data manipulations, or run reports.</p> <p>Similarly we can add a new partition to handle new data. We can create an empty partition in the partitioned table just as the original partitions were created above:</p> <pre data-language="sql">
CREATE TABLE measurement_y2008m02 PARTITION OF measurement
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')
    TABLESPACE fasttablespace;</pre> <p>As an alternative, it is sometimes more convenient to create the new table outside the partition structure, and make it a proper partition later. This allows the data to be loaded, checked, and transformed prior to it appearing in the partitioned table:</p> <pre data-language="sql">CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)
  TABLESPACE fasttablespace;

ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );

\copy measurement_y2008m02 from 'measurement_y2008m02'
-- possibly some other data preparation work

ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02
    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' );</pre> <p>Before running the <code class="command">ATTACH PARTITION</code> command, it is recommended to create a <code class="literal">CHECK</code> constraint on the table to be attached describing the desired partition constraint. That way, the system will be able to skip the scan to validate the implicit partition constraint. Without such a constraint, the table will be scanned to validate the partition constraint while holding an <code class="literal">ACCESS EXCLUSIVE</code> lock on the parent table. One may then drop the constraint after <code class="command">ATTACH PARTITION</code> is finished, because it is no longer necessary.</p> </div> <div class="sect3" id="DDL-PARTITIONING-DECLARATIVE-LIMITATIONS">    <h3 class="title">5.10.2.3. Limitations</h3>    <p>The following limitations apply to partitioned tables:</p>  <ul> <li> <p>There is no facility available to create the matching indexes on all partitions automatically. Indexes must be added to each partition with separate commands. This also means that there is no way to create a primary key, unique constraint, or exclusion constraint spanning all partitions; it is only possible to constrain each leaf partition individually.</p> </li> <li> <p>Since primary keys are not supported on partitioned tables, foreign keys referencing partitioned tables are not supported, nor are foreign key references from a partitioned table to some other table.</p> </li> <li> <p>Using the <code class="literal">ON CONFLICT</code> clause with partitioned tables will cause an error, because unique or exclusion constraints can only be created on individual partitions. There is no support for enforcing uniqueness (or an exclusion constraint) across an entire partitioning hierarchy.</p> </li> <li> <p>An <code class="command">UPDATE</code> that causes a row to move from one partition to another fails, because the new value of the row fails to satisfy the implicit partition constraint of the original partition.</p> </li> <li> <p>Row triggers, if necessary, must be defined on individual partitions, not the partitioned table.</p> </li> </ul>  </div> </div> <div class="sect2" id="DDL-PARTITIONING-IMPLEMENTATION-INHERITANCE">    <h2 class="title">5.10.3. Implementation Using Inheritance</h2>    <p>While the built-in declarative partitioning is suitable for most common use cases, there are some circumstances where a more flexible approach may be useful. Partitioning can be implemented using table inheritance, which allows for several features which are not supported by declarative partitioning, such as:</p>  <ul> <li> <p>Partitioning enforces a rule that all partitions must have exactly the same set of columns as the parent, but table inheritance allows children to have extra columns not present in the parent.</p> </li> <li> <p>Table inheritance allows for multiple inheritance.</p> </li> <li> <p>Declarative partitioning only supports list and range partitioning, whereas table inheritance allows data to be divided in a manner of the user's choosing. (Note, however, that if constraint exclusion is unable to prune partitions effectively, query performance will be very poor.)</p> </li> <li> <p>Some operations require a stronger lock when using declarative partitioning than when using table inheritance. For example, adding or removing a partition to or from a partitioned table requires taking an <code class="literal">ACCESS EXCLUSIVE</code> lock on the parent table, whereas a <code class="literal">SHARE UPDATE EXCLUSIVE</code> lock is enough in the case of regular inheritance.</p> </li> </ul>  <div class="sect3" id="DDL-PARTITIONING-INHERITANCE-EXAMPLE">    <h3 class="title">5.10.3.1. Example</h3>    <p>We use the same <code class="structname">measurement</code> table we used above. To implement it as a partitioned table using inheritance, use the following steps:</p> <div class="orderedlist"> <ol class="orderedlist compact" type="1"> <li> <p>Create the <span class="quote">“<span class="quote">master</span>”</span> table, from which all of the partitions will inherit. This table will contain no data. Do not define any check constraints on this table, unless you intend them to be applied equally to all partitions. There is no point in defining any indexes or unique constraints on it, either. For our example, master table is the <code class="structname">measurement</code> table as originally defined.</p> </li> <li> <p>Create several <span class="quote">“<span class="quote">child</span>”</span> tables that each inherit from the master table. Normally, these tables will not add any columns to the set inherited from the master. Just as with declarative partitioning, these partitions are in every way normal PostgreSQL tables (or foreign tables).</p> <pre data-language="sql">
CREATE TABLE measurement_y2006m02 () INHERITS (measurement);
CREATE TABLE measurement_y2006m03 () INHERITS (measurement);
...
CREATE TABLE measurement_y2007m11 () INHERITS (measurement);
CREATE TABLE measurement_y2007m12 () INHERITS (measurement);
CREATE TABLE measurement_y2008m01 () INHERITS (measurement);</pre>
</li> <li> <p>Add non-overlapping table constraints to the partition tables to define the allowed key values in each partition.</p> <p>Typical examples would be:</p> <pre data-language="sql">CHECK ( x = 1 )
CHECK ( county IN ( 'Oxfordshire', 'Buckinghamshire', 'Warwickshire' ))
CHECK ( outletID &gt;= 100 AND outletID &lt; 200 )</pre> <p>Ensure that the constraints guarantee that there is no overlap between the key values permitted in different partitions. A common mistake is to set up range constraints like:</p> <pre data-language="sql">CHECK ( outletID BETWEEN 100 AND 200 )
CHECK ( outletID BETWEEN 200 AND 300 )</pre> <p>This is wrong since it is not clear which partition the key value 200 belongs in.</p> <p>It would be better to instead create partitions as follows:</p> <pre data-language="sql">CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate &gt;= DATE '2006-03-01' AND logdate &lt; DATE '2006-04-01' )
) INHERITS (measurement);

...
CREATE TABLE measurement_y2007m11 (
    CHECK ( logdate &gt;= DATE '2007-11-01' AND logdate &lt; DATE '2007-12-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2007m12 (
    CHECK ( logdate &gt;= DATE '2007-12-01' AND logdate &lt; DATE '2008-01-01' )
) INHERITS (measurement);

CREATE TABLE measurement_y2008m01 (
    CHECK ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
) INHERITS (measurement);</pre>
</li> <li> <p>For each partition, create an index on the key column(s), as well as any other indexes you might want.</p> <pre data-language="sql">
CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);
CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);
CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);
CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);
CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);</pre>
</li> <li> <p>We want our application to be able to say <code class="literal">INSERT INTO measurement ...</code> and have the data be redirected into the appropriate partition table. We can arrange that by attaching a suitable trigger function to the master table. If data will be added only to the latest partition, we can use a very simple trigger function:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;</pre> <p>After creating the function, we create a trigger which calls the trigger function:</p> <pre data-language="sql">
CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE PROCEDURE measurement_insert_trigger();</pre> <p>We must redefine the trigger function each month so that it always points to the current partition. The trigger definition does not need to be updated, however.</p> <p>We might want to insert data and have the server automatically locate the partition into which the row should be added. We could do this with a more complex trigger function, for example:</p> <pre data-language="sql">
CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate &gt;= DATE '2006-02-01' AND
         NEW.logdate &lt; DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate &gt;= DATE '2006-03-01' AND
            NEW.logdate &lt; DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ...
    ELSIF ( NEW.logdate &gt;= DATE '2008-01-01' AND
            NEW.logdate &lt; DATE '2008-02-01' ) THEN
        INSERT INTO measurement_y2008m01 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$
LANGUAGE plpgsql;</pre> <p>The trigger definition is the same as before. Note that each <code class="literal">IF</code> test must exactly match the <code class="literal">CHECK</code> constraint for its partition.</p> <p>While this function is more complex than the single-month case, it doesn't need to be updated as often, since branches can be added in advance of being needed.</p> <blockquote class="note"> <h3 class="title">Note</h3> <p>In practice it might be best to check the newest partition first, if most inserts go into that partition. For simplicity we have shown the trigger's tests in the same order as in other parts of this example.</p> </blockquote> <p>A different approach to redirecting inserts into the appropriate partition table is to set up rules, instead of a trigger, on the master table. For example:</p> <pre data-language="sql">
CREATE RULE measurement_insert_y2006m02 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2006-02-01' AND logdate &lt; DATE '2006-03-01' )
DO INSTEAD
    INSERT INTO measurement_y2006m02 VALUES (NEW.*);
...
CREATE RULE measurement_insert_y2008m01 AS
ON INSERT TO measurement WHERE
    ( logdate &gt;= DATE '2008-01-01' AND logdate &lt; DATE '2008-02-01' )
DO INSTEAD
    INSERT INTO measurement_y2008m01 VALUES (NEW.*);</pre> <p>A rule has significantly more overhead than a trigger, but the overhead is paid once per query rather than once per row, so this method might be advantageous for bulk-insert situations. In most cases, however, the trigger method will offer better performance.</p> <p>Be aware that <code class="command">COPY</code> ignores rules. If you want to use <code class="command">COPY</code> to insert data, you'll need to copy into the correct partition table rather than into the master. <code class="command">COPY</code> does fire triggers, so you can use it normally if you use the trigger approach.</p> <p>Another disadvantage of the rule approach is that there is no simple way to force an error if the set of rules doesn't cover the insertion date; the data will silently go into the master table instead.</p> </li> <li> <p>Ensure that the <a class="xref" href="../runtime-config-query/#GUC-CONSTRAINT-EXCLUSION">constraint_exclusion</a> configuration parameter is not disabled in <code class="filename">postgresql.conf</code>. If it is, queries will not be optimized as desired.</p> </li> </ol> </div> <p>As we can see, a complex partitioning scheme could require a substantial amount of DDL. In the above example we would be creating a new partition each month, so it might be wise to write a script that generates the required DDL automatically.</p> </div> <div class="sect3" id="DDL-PARTITIONING-INHERITANCE-MAINTENANCE">    <h3 class="title">5.10.3.2. Partition Maintenance</h3>    <p>To remove old data quickly, simply drop the partition that is no longer necessary:</p> <pre data-language="sql">DROP TABLE measurement_y2006m02;</pre> <p>To remove the partition from the partitioned table but retain access to it as a table in its own right:</p> <pre data-language="sql">
ALTER TABLE measurement_y2006m02 NO INHERIT measurement;</pre> <p>To add a new partition to handle new data, create an empty partition just as the original partitions were created above:</p> <pre data-language="sql">CREATE TABLE measurement_y2008m02 (
    CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' )
) INHERITS (measurement);</pre> <p>Alternatively, one may want to create the new table outside the partition structure, and make it a partition after the data is loaded, checked, and transformed.</p> <pre data-language="sql">CREATE TABLE measurement_y2008m02
  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);
ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02
   CHECK ( logdate &gt;= DATE '2008-02-01' AND logdate &lt; DATE '2008-03-01' );
\copy measurement_y2008m02 from 'measurement_y2008m02'
-- possibly some other data preparation work
ALTER TABLE measurement_y2008m02 INHERIT measurement;</pre>
</div> <div class="sect3" id="DDL-PARTITIONING-INHERITANCE-CAVEATS">    <h3 class="title">5.10.3.3. Caveats</h3>    <p>The following caveats apply to partitioned tables implemented using inheritance:</p>  <ul> <li> <p>There is no automatic way to verify that all of the <code class="literal">CHECK</code> constraints are mutually exclusive. It is safer to create code that generates partitions and creates and/or modifies associated objects than to write each by hand.</p> </li> <li> <p>The schemes shown here assume that the partition key column(s) of a row never change, or at least do not change enough to require it to move to another partition. An <code class="command">UPDATE</code> that attempts to do that will fail because of the <code class="literal">CHECK</code> constraints. If you need to handle such cases, you can put suitable update triggers on the partition tables, but it makes management of the structure much more complicated.</p> </li> <li> <p>If you are using manual <code class="command">VACUUM</code> or <code class="command">ANALYZE</code> commands, don't forget that you need to run them on each partition individually. A command like:</p> <pre data-language="sql">ANALYZE measurement;</pre> <p>will only process the master table.</p> </li> <li> <p><code class="command">INSERT</code> statements with <code class="literal">ON CONFLICT</code> clauses are unlikely to work as expected, as the <code class="literal">ON CONFLICT</code> action is only taken in case of unique violations on the specified target relation, not its child relations.</p> </li> <li> <p>Triggers or rules will be needed to route rows to the desired partition, unless the application is explicitly aware of the partitioning scheme. Triggers may be complicated to write, and will be much slower than the tuple routing performed internally by declarative partitioning.</p> </li> </ul>  </div> </div> <div class="sect2" id="DDL-PARTITIONING-CONSTRAINT-EXCLUSION">    <h2 class="title">5.10.4. Partitioning and Constraint Exclusion</h2>     <p><em class="firstterm">Constraint exclusion</em> is a query optimization technique that improves performance for partitioned tables defined in the fashion described above (both declaratively partitioned tables and those implemented using inheritance). As an example:</p> <pre data-language="sql">SET constraint_exclusion = on;
SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';</pre> <p>Without constraint exclusion, the above query would scan each of the partitions of the <code class="structname">measurement</code> table. With constraint exclusion enabled, the planner will examine the constraints of each partition and try to prove that the partition need not be scanned because it could not contain any rows meeting the query's <code class="literal">WHERE</code> clause. When the planner can prove this, it excludes the partition from the query plan.</p> <p>You can use the <code class="command">EXPLAIN</code> command to show the difference between a plan with <code class="varname">constraint_exclusion</code> on and a plan with it off. A typical unoptimized plan for this type of table setup is:</p> <pre data-language="sql">SET constraint_exclusion = off;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';

                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=158.66..158.68 rows=1 width=0)
   -&gt;  Append  (cost=0.00..151.88 rows=2715 width=0)
         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m02 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2006m03 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
...
         -&gt;  Seq Scan on measurement_y2007m12 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)</pre> <p>Some or all of the partitions might use index scans instead of full-table sequential scans, but the point here is that there is no need to scan the older partitions at all to answer this query. When we enable constraint exclusion, we get a significantly cheaper plan that will deliver the same answer:</p> <pre data-language="sql">SET constraint_exclusion = on;
EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE '2008-01-01';
                                          QUERY PLAN
-----------------------------------------------------------------------------------------------
 Aggregate  (cost=63.47..63.48 rows=1 width=0)
   -&gt;  Append  (cost=0.00..60.75 rows=1086 width=0)
         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)
         -&gt;  Seq Scan on measurement_y2008m01 measurement  (cost=0.00..30.38 rows=543 width=0)
               Filter: (logdate &gt;= '2008-01-01'::date)</pre> <p>Note that constraint exclusion is driven only by <code class="literal">CHECK</code> constraints, not by the presence of indexes. Therefore it isn't necessary to define indexes on the key columns. Whether an index needs to be created for a given partition depends on whether you expect that queries that scan the partition will generally scan a large part of the partition or just a small part. An index will be helpful in the latter case but not the former.</p> <p>The default (and recommended) setting of <a class="xref" href="../runtime-config-query/#GUC-CONSTRAINT-EXCLUSION">constraint_exclusion</a> is actually neither <code class="literal">on</code> nor <code class="literal">off</code>, but an intermediate setting called <code class="literal">partition</code>, which causes the technique to be applied only to queries that are likely to be working on partitioned tables. The <code class="literal">on</code> setting causes the planner to examine <code class="literal">CHECK</code> constraints in all queries, even simple ones that are unlikely to benefit.</p> <p>The following caveats apply to constraint exclusion, which is used by both inheritance and partitioned tables:</p>  <ul> <li> <p>Constraint exclusion only works when the query's <code class="literal">WHERE</code> clause contains constants (or externally supplied parameters). For example, a comparison against a non-immutable function such as <code class="function">CURRENT_TIMESTAMP</code> cannot be optimized, since the planner cannot know which partition the function value might fall into at run time.</p> </li> <li> <p>Keep the partitioning constraints simple, else the planner may not be able to prove that partitions don't need to be visited. Use simple equality conditions for list partitioning, or simple range tests for range partitioning, as illustrated in the preceding examples. A good rule of thumb is that partitioning constraints should contain only comparisons of the partitioning column(s) to constants using B-tree-indexable operators, which applies even to partitioned tables, because only B-tree-indexable column(s) are allowed in the partition key. (This is not a problem when using declarative partitioning, since the automatically generated constraints are simple enough to be understood by the planner.)</p> </li> <li> <p>All constraints on all partitions of the master table are examined during constraint exclusion, so large numbers of partitions are likely to increase query planning time considerably. Partitioning using these techniques will work well with up to perhaps a hundred partitions; don't try to use many thousands of partitions.</p> </li> </ul>  </div>  <div class="navfooter">  <table summary="Navigation footer"> <tr> <td width="40%" align="left">
<a accesskey="p" href="../ddl-inherit/">Prev</a> </td> <td width="20%" align="center"><a accesskey="u" href="https://www.postgresql.org/docs/10/static/ddl.html" target="_blank">Up</a></td> <td width="40%" align="right"> <a accesskey="n" href="../ddl-foreign-data/">Next</a>
</td> </tr> <tr> <td width="40%" align="left"> 5.9. Inheritance </td> <td width="20%" align="center"><a accesskey="h" href="https://www.postgresql.org/docs/10/static/index.html" target="_blank">Home</a></td> <td width="40%" align="right"> 5.11. Foreign Data</td> </tr> </table> </div>
<div class="_attribution">
  <p class="_attribution-p">
    © 1996–2018 The PostgreSQL Global Development Group<br>Licensed under the PostgreSQL License.<br>
    <a href="https://www.postgresql.org/docs/10/static/ddl-partitioning.html" class="_attribution-link" target="_blank">https://www.postgresql.org/docs/10/static/ddl-partitioning.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
