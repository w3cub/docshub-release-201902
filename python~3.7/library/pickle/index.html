
<!DOCTYPE HTML>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Pickle - Python 3.7 - W3cubDocs</title>
  
  <meta name="description" content=" Source code&#58; Lib&#47;pickle.py ">
  <meta name="keywords" content="pickle, —, python, object, serialization, -, python~3.7">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="mobile-web-app-capable" content="yes">
  
  <link rel="canonical" href="http://docs.w3cub.com/python~3.7/library/pickle/">
  <link href="/favicon.png" rel="icon">
  <link rel="stylesheet" type="text/css" href="/assets/application-6cc8ff3c95d062e2cd87636799240e79e4553263ad7de9cda9464063203db436.css" integrity="sha256-bMj/PJXQYuLNh2NnmSQOeeRVMmOtfenNqUZAYyA9tDY=" crossorigin="anonymous">
  <script type="text/javascript" integrity="sha256-JOOcjTvTbt5QE9AmOH1rrXz8aKKfHMsOthbsjt9CNfk=" crossorigin="anonymous" src="/assets/application-24e39c8d3bd36ede5013d026387d6bad7cfc68a29f1ccb0eb616ec8edf4235f9.js"></script>
  <script src="/json/python~3.7.js"></script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-71174418-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body>
	<div class="_app">
	<header class="_header">
  
  <form class="_search">
    <input type="search" class="_search-input" placeholder="Search&hellip;" autocomplete="off" autocapitalize="off" autocorrect="off" spellcheck="false" maxlength="20">
    <a class="_search-clear"></a>
    <div class="_search-tag"></div>
  </form>
  
  <a class="_home-link" href="/" ></a>
  <a class="_menu-link"></a>
  <h1 class="_logo">
    <a href="/" class="_nav-link" title="API Documentation Browser">W3cubDocs</a>
  </h1>
  
  <span class="_logo-sub-nav">/</span><span class="_logo-sub-nav"><a href="/python~3.7/" class="_nav-link" title="" style="margin-left:0;">Python 3.7</a></span>
  
  <nav class="_nav">
    <a href="/app/" class="_nav-link ">App</a>
    <a href="/about/" class="_nav-link ">About</a>
  </nav>
</header>
	<section class="_sidebar">
		<div class="_list">
			
		</div>
	</section>
	<section class="_container ">
		<div class="_content">
			<div class="_page _python">
				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档开头内嵌 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2572770204602497"
     data-ad-slot="8852552735"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
				
<h1 id="pickle-python-object-serialization">pickle — Python object serialization</h1> <p id="module-pickle"><strong>Source code:</strong> <a class="reference external" href="https://github.com/python/cpython/tree/3.7/Lib/pickle.py" target="_blank">Lib/pickle.py</a></p>  <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module implements binary protocols for serializing and de-serializing a Python object structure. <em>“Pickling”</em> is the process whereby a Python object hierarchy is converted into a byte stream, and <em>“unpickling”</em> is the inverse operation, whereby a byte stream (from a <a class="reference internal" href="https://docs.python.org/3.7/glossary.html#term-binary-file" target="_blank"><span class="xref std std-term">binary file</span></a> or <a class="reference internal" href="https://docs.python.org/3.7/glossary.html#term-bytes-like-object" target="_blank"><span class="xref std std-term">bytes-like object</span></a>) is converted back into an object hierarchy. Pickling (and unpickling) is alternatively known as “serialization”, “marshalling,” <a class="footnote-reference" href="#id6" id="id1">[1]</a> or “flattening”; however, to avoid confusion, the terms used here are “pickling” and “unpickling”.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module is not secure against erroneous or maliciously constructed data. Never unpickle data received from an untrusted or unauthenticated source.</p> </div>  <h2 id="relationship-to-other-python-modules">Relationship to other Python modules</h2>  <h3 id="comparison-with-marshal">Comparison with <code>marshal</code>
</h3> <p>Python has a more primitive serialization module called <a class="reference internal" href="../marshal/#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a>, but in general <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> should always be the preferred way to serialize Python objects. <a class="reference internal" href="../marshal/#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> exists primarily to support Python’s <code>.pyc</code> files.</p> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module differs from <a class="reference internal" href="../marshal/#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> in several significant ways:</p> <ul> <li>
<p class="first">The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module keeps track of the objects it has already serialized, so that later references to the same object won’t be serialized again. <a class="reference internal" href="../marshal/#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> doesn’t do this.</p> <p>This has implications both for recursive objects and object sharing. Recursive objects are objects that contain references to themselves. These are not handled by marshal, and in fact, attempting to marshal recursive objects will crash your Python interpreter. Object sharing happens when there are multiple references to the same object in different places in the object hierarchy being serialized. <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> stores such objects only once, and ensures that all other references point to the master copy. Shared objects remain shared, which can be very important for mutable objects.</p> </li> <li>
<a class="reference internal" href="../marshal/#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> cannot be used to serialize user-defined classes and their instances. <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> can save and restore class instances transparently, however the class definition must be importable and live in the same module as when the object was stored. </li> <li>The <a class="reference internal" href="../marshal/#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> serialization format is not guaranteed to be portable across Python versions. Because its primary job in life is to support <code>.pyc</code> files, the Python implementers reserve the right to change the serialization format in non-backwards compatible ways should the need arise. The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> serialization format is guaranteed to be backwards compatible across Python releases. </li> </ul>   <h3 id="comparison-with-json">Comparison with <code>json</code>
</h3> <p>There are fundamental differences between the pickle protocols and <a class="reference external" href="http://json.org" target="_blank">JSON (JavaScript Object Notation)</a>:</p> <ul class="simple"> <li>JSON is a text serialization format (it outputs unicode text, although most of the time it is then encoded to <code>utf-8</code>), while pickle is a binary serialization format;</li> <li>JSON is human-readable, while pickle is not;</li> <li>JSON is interoperable and widely used outside of the Python ecosystem, while pickle is Python-specific;</li> <li>JSON, by default, can only represent a subset of the Python built-in types, and no custom classes; pickle can represent an extremely large number of Python types (many of them automatically, by clever usage of Python’s introspection facilities; complex cases can be tackled by implementing <a class="reference internal" href="#pickle-inst"><span class="std std-ref">specific object APIs</span></a>).</li> </ul> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">The <a class="reference internal" href="../json/#module-json" title="json: Encode and decode the JSON format."><code>json</code></a> module: a standard library module allowing JSON serialization and deserialization.</p> </div>    <h2 id="pickle-protocols">Data stream format</h2> <p id="data-stream-format">The data format used by <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> is Python-specific. This has the advantage that there are no restrictions imposed by external standards such as JSON or XDR (which can’t represent pointer sharing); however it means that non-Python programs may not be able to reconstruct pickled Python objects.</p> <p>By default, the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> data format uses a relatively compact binary representation. If you need optimal size characteristics, you can efficiently <a class="reference internal" href="../archiving/"><span class="doc">compress</span></a> pickled data.</p> <p>The module <a class="reference internal" href="../pickletools/#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code>pickletools</code></a> contains tools for analyzing data streams generated by <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a>. <a class="reference internal" href="../pickletools/#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code>pickletools</code></a> source code has extensive comments about opcodes used by pickle protocols.</p> <p>There are currently 5 different protocols which can be used for pickling. The higher the protocol used, the more recent the version of Python needed to read the pickle produced.</p> <ul class="simple"> <li>Protocol version 0 is the original “human-readable” protocol and is backwards compatible with earlier versions of Python.</li> <li>Protocol version 1 is an old binary format which is also compatible with earlier versions of Python.</li> <li>Protocol version 2 was introduced in Python 2.3. It provides much more efficient pickling of <a class="reference internal" href="https://docs.python.org/3.7/glossary.html#term-new-style-class" target="_blank"><span class="xref std std-term">new-style class</span></a>es. Refer to <a class="pep reference external" href="https://www.python.org/dev/peps/pep-0307" id="index-2" target="_blank"><strong>PEP 307</strong></a> for information about improvements brought by protocol 2.</li> <li>Protocol version 3 was added in Python 3.0. It has explicit support for <a class="reference internal" href="../stdtypes/#bytes" title="bytes"><code>bytes</code></a> objects and cannot be unpickled by Python 2.x. This is the default protocol, and the recommended protocol when compatibility with other Python 3 versions is required.</li> <li>Protocol version 4 was added in Python 3.4. It adds support for very large objects, pickling more kinds of objects, and some data format optimizations. Refer to <a class="pep reference external" href="https://www.python.org/dev/peps/pep-3154" id="index-3" target="_blank"><strong>PEP 3154</strong></a> for information about improvements brought by protocol 4.</li> </ul> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Serialization is a more primitive notion than persistence; although <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> reads and writes file objects, it does not handle the issue of naming persistent objects, nor the (even more complicated) issue of concurrent access to persistent objects. The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module can transform a complex object into a byte stream and it can transform the byte stream into an object with the same internal structure. Perhaps the most obvious thing to do with these byte streams is to write them onto a file, but it is also conceivable to send them across a network or store them in a database. The <a class="reference internal" href="../shelve/#module-shelve" title="shelve: Python object persistence."><code>shelve</code></a> module provides a simple interface to pickle and unpickle objects on DBM-style database files.</p> </div>   <h2 id="module-interface">Module Interface</h2> <p>To serialize an object hierarchy, you simply call the <a class="reference internal" href="#pickle.dumps" title="pickle.dumps"><code>dumps()</code></a> function. Similarly, to de-serialize a data stream, you call the <a class="reference internal" href="#pickle.loads" title="pickle.loads"><code>loads()</code></a> function. However, if you want more control over serialization and de-serialization, you can create a <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a> or an <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code>Unpickler</code></a> object, respectively.</p> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module provides the following constants:</p> <dl class="data"> <dt id="pickle.HIGHEST_PROTOCOL">
<code>pickle.HIGHEST_PROTOCOL</code> </dt> <dd>
<p>An integer, the highest <a class="reference internal" href="#pickle-protocols"><span class="std std-ref">protocol version</span></a> available. This value can be passed as a <em>protocol</em> value to functions <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code>dump()</code></a> and <a class="reference internal" href="#pickle.dumps" title="pickle.dumps"><code>dumps()</code></a> as well as the <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a> constructor.</p> </dd>
</dl> <dl class="data"> <dt id="pickle.DEFAULT_PROTOCOL">
<code>pickle.DEFAULT_PROTOCOL</code> </dt> <dd>
<p>An integer, the default <a class="reference internal" href="#pickle-protocols"><span class="std std-ref">protocol version</span></a> used for pickling. May be less than <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code>HIGHEST_PROTOCOL</code></a>. Currently the default protocol is 3, a new protocol designed for Python 3.</p> </dd>
</dl> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module provides the following functions to make the pickling process more convenient:</p> <dl class="function"> <dt id="pickle.dump">
<code>pickle.dump(obj, file, protocol=None, *, fix_imports=True)</code> </dt> <dd>
<p>Write a pickled representation of <em>obj</em> to the open <a class="reference internal" href="https://docs.python.org/3.7/glossary.html#term-file-object" target="_blank"><span class="xref std std-term">file object</span></a> <em>file</em>. This is equivalent to <code>Pickler(file, protocol).dump(obj)</code>.</p> <p>The optional <em>protocol</em> argument, an integer, tells the pickler to use the given protocol; supported protocols are 0 to <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code>HIGHEST_PROTOCOL</code></a>. If not specified, the default is <a class="reference internal" href="#pickle.DEFAULT_PROTOCOL" title="pickle.DEFAULT_PROTOCOL"><code>DEFAULT_PROTOCOL</code></a>. If a negative number is specified, <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code>HIGHEST_PROTOCOL</code></a> is selected.</p> <p>The <em>file</em> argument must have a write() method that accepts a single bytes argument. It can thus be an on-disk file opened for binary writing, an <a class="reference internal" href="../io/#io.BytesIO" title="io.BytesIO"><code>io.BytesIO</code></a> instance, or any other custom object that meets this interface.</p> <p>If <em>fix_imports</em> is true and <em>protocol</em> is less than 3, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2.</p> </dd>
</dl> <dl class="function"> <dt id="pickle.dumps">
<code>pickle.dumps(obj, protocol=None, *, fix_imports=True)</code> </dt> <dd>
<p>Return the pickled representation of the object as a <a class="reference internal" href="../stdtypes/#bytes" title="bytes"><code>bytes</code></a> object, instead of writing it to a file.</p> <p>Arguments <em>protocol</em> and <em>fix_imports</em> have the same meaning as in <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code>dump()</code></a>.</p> </dd>
</dl> <dl class="function"> <dt id="pickle.load">
<code>pickle.load(file, *, fix_imports=True, encoding="ASCII", errors="strict")</code> </dt> <dd>
<p>Read a pickled object representation from the open <a class="reference internal" href="https://docs.python.org/3.7/glossary.html#term-file-object" target="_blank"><span class="xref std std-term">file object</span></a> <em>file</em> and return the reconstituted object hierarchy specified therein. This is equivalent to <code>Unpickler(file).load()</code>.</p> <p>The protocol version of the pickle is detected automatically, so no protocol argument is needed. Bytes past the pickled object’s representation are ignored.</p> <p>The argument <em>file</em> must have two methods, a read() method that takes an integer argument, and a readline() method that requires no arguments. Both methods should return bytes. Thus <em>file</em> can be an on-disk file opened for binary reading, an <a class="reference internal" href="../io/#io.BytesIO" title="io.BytesIO"><code>io.BytesIO</code></a> object, or any other custom object that meets this interface.</p> <p>Optional keyword arguments are <em>fix_imports</em>, <em>encoding</em> and <em>errors</em>, which are used to control compatibility support for pickle stream generated by Python 2. If <em>fix_imports</em> is true, pickle will try to map the old Python 2 names to the new names used in Python 3. The <em>encoding</em> and <em>errors</em> tell pickle how to decode 8-bit string instances pickled by Python 2; these default to ‘ASCII’ and ‘strict’, respectively. The <em>encoding</em> can be ‘bytes’ to read these 8-bit string instances as bytes objects.</p> </dd>
</dl> <dl class="function"> <dt id="pickle.loads">
<code>pickle.loads(bytes_object, *, fix_imports=True, encoding="ASCII", errors="strict")</code> </dt> <dd>
<p>Read a pickled object hierarchy from a <a class="reference internal" href="../stdtypes/#bytes" title="bytes"><code>bytes</code></a> object and return the reconstituted object hierarchy specified therein.</p> <p>The protocol version of the pickle is detected automatically, so no protocol argument is needed. Bytes past the pickled object’s representation are ignored.</p> <p>Optional keyword arguments are <em>fix_imports</em>, <em>encoding</em> and <em>errors</em>, which are used to control compatibility support for pickle stream generated by Python 2. If <em>fix_imports</em> is true, pickle will try to map the old Python 2 names to the new names used in Python 3. The <em>encoding</em> and <em>errors</em> tell pickle how to decode 8-bit string instances pickled by Python 2; these default to ‘ASCII’ and ‘strict’, respectively. The <em>encoding</em> can be ‘bytes’ to read these 8-bit string instances as bytes objects.</p> </dd>
</dl> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module defines three exceptions:</p> <dl class="exception"> <dt id="pickle.PickleError">
<code>exception pickle.PickleError</code> </dt> <dd>
<p>Common base class for the other pickling exceptions. It inherits <a class="reference internal" href="../exceptions/#Exception" title="Exception"><code>Exception</code></a>.</p> </dd>
</dl> <dl class="exception"> <dt id="pickle.PicklingError">
<code>exception pickle.PicklingError</code> </dt> <dd>
<p>Error raised when an unpicklable object is encountered by <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a>. It inherits <a class="reference internal" href="#pickle.PickleError" title="pickle.PickleError"><code>PickleError</code></a>.</p> <p>Refer to <a class="reference internal" href="#pickle-picklable"><span class="std std-ref">What can be pickled and unpickled?</span></a> to learn what kinds of objects can be pickled.</p> </dd>
</dl> <dl class="exception"> <dt id="pickle.UnpicklingError">
<code>exception pickle.UnpicklingError</code> </dt> <dd>
<p>Error raised when there is a problem unpickling an object, such as a data corruption or a security violation. It inherits <a class="reference internal" href="#pickle.PickleError" title="pickle.PickleError"><code>PickleError</code></a>.</p> <p>Note that other exceptions may also be raised during unpickling, including (but not necessarily limited to) AttributeError, EOFError, ImportError, and IndexError.</p> </dd>
</dl> <p>The <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module exports two classes, <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a> and <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code>Unpickler</code></a>:</p> <dl class="class"> <dt id="pickle.Pickler">
<code>class pickle.Pickler(file, protocol=None, *, fix_imports=True)</code> </dt> <dd>
<p>This takes a binary file for writing a pickle data stream.</p> <p>The optional <em>protocol</em> argument, an integer, tells the pickler to use the given protocol; supported protocols are 0 to <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code>HIGHEST_PROTOCOL</code></a>. If not specified, the default is <a class="reference internal" href="#pickle.DEFAULT_PROTOCOL" title="pickle.DEFAULT_PROTOCOL"><code>DEFAULT_PROTOCOL</code></a>. If a negative number is specified, <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code>HIGHEST_PROTOCOL</code></a> is selected.</p> <p>The <em>file</em> argument must have a write() method that accepts a single bytes argument. It can thus be an on-disk file opened for binary writing, an <a class="reference internal" href="../io/#io.BytesIO" title="io.BytesIO"><code>io.BytesIO</code></a> instance, or any other custom object that meets this interface.</p> <p>If <em>fix_imports</em> is true and <em>protocol</em> is less than 3, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2.</p> <dl class="method"> <dt id="pickle.Pickler.dump">
<code>dump(obj)</code> </dt> <dd>
<p>Write a pickled representation of <em>obj</em> to the open file object given in the constructor.</p> </dd>
</dl> <dl class="method"> <dt id="pickle.Pickler.persistent_id">
<code>persistent_id(obj)</code> </dt> <dd>
<p>Do nothing by default. This exists so a subclass can override it.</p> <p>If <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code>persistent_id()</code></a> returns <code>None</code>, <em>obj</em> is pickled as usual. Any other value causes <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a> to emit the returned value as a persistent ID for <em>obj</em>. The meaning of this persistent ID should be defined by <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code>Unpickler.persistent_load()</code></a>. Note that the value returned by <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code>persistent_id()</code></a> cannot itself have a persistent ID.</p> <p>See <a class="reference internal" href="#pickle-persistent"><span class="std std-ref">Persistence of External Objects</span></a> for details and examples of uses.</p> </dd>
</dl> <dl class="attribute"> <dt id="pickle.Pickler.dispatch_table">
<code>dispatch_table</code> </dt> <dd>
<p>A pickler object’s dispatch table is a registry of <em>reduction functions</em> of the kind which can be declared using <a class="reference internal" href="../copyreg/#copyreg.pickle" title="copyreg.pickle"><code>copyreg.pickle()</code></a>. It is a mapping whose keys are classes and whose values are reduction functions. A reduction function takes a single argument of the associated class and should conform to the same interface as a <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> method.</p> <p>By default, a pickler object will not have a <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code>dispatch_table</code></a> attribute, and it will instead use the global dispatch table managed by the <a class="reference internal" href="../copyreg/#module-copyreg" title="copyreg: Register pickle support functions."><code>copyreg</code></a> module. However, to customize the pickling for a specific pickler object one can set the <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code>dispatch_table</code></a> attribute to a dict-like object. Alternatively, if a subclass of <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a> has a <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code>dispatch_table</code></a> attribute then this will be used as the default dispatch table for instances of that class.</p> <p>See <a class="reference internal" href="#pickle-dispatch"><span class="std std-ref">Dispatch Tables</span></a> for usage examples.</p> <div class="versionadded"> <p><span class="versionmodified">New in version 3.3.</span></p> </div> </dd>
</dl> <dl class="attribute"> <dt id="pickle.Pickler.fast">
<code>fast</code> </dt> <dd>
<p>Deprecated. Enable fast mode if set to a true value. The fast mode disables the usage of memo, therefore speeding the pickling process by not generating superfluous PUT opcodes. It should not be used with self-referential objects, doing otherwise will cause <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>Pickler</code></a> to recurse infinitely.</p> <p>Use <a class="reference internal" href="../pickletools/#pickletools.optimize" title="pickletools.optimize"><code>pickletools.optimize()</code></a> if you need more compact pickles.</p> </dd>
</dl> </dd>
</dl> <dl class="class"> <dt id="pickle.Unpickler">
<code>class pickle.Unpickler(file, *, fix_imports=True, encoding="ASCII", errors="strict")</code> </dt> <dd>
<p>This takes a binary file for reading a pickle data stream.</p> <p>The protocol version of the pickle is detected automatically, so no protocol argument is needed.</p> <p>The argument <em>file</em> must have two methods, a read() method that takes an integer argument, and a readline() method that requires no arguments. Both methods should return bytes. Thus <em>file</em> can be an on-disk file object opened for binary reading, an <a class="reference internal" href="../io/#io.BytesIO" title="io.BytesIO"><code>io.BytesIO</code></a> object, or any other custom object that meets this interface.</p> <p>Optional keyword arguments are <em>fix_imports</em>, <em>encoding</em> and <em>errors</em>, which are used to control compatibility support for pickle stream generated by Python 2. If <em>fix_imports</em> is true, pickle will try to map the old Python 2 names to the new names used in Python 3. The <em>encoding</em> and <em>errors</em> tell pickle how to decode 8-bit string instances pickled by Python 2; these default to ‘ASCII’ and ‘strict’, respectively. The <em>encoding</em> can be ‘bytes’ to read these 8-bit string instances as bytes objects.</p> <dl class="method"> <dt id="pickle.Unpickler.load">
<code>load()</code> </dt> <dd>
<p>Read a pickled object representation from the open file object given in the constructor, and return the reconstituted object hierarchy specified therein. Bytes past the pickled object’s representation are ignored.</p> </dd>
</dl> <dl class="method"> <dt id="pickle.Unpickler.persistent_load">
<code>persistent_load(pid)</code> </dt> <dd>
<p>Raise an <a class="reference internal" href="#pickle.UnpicklingError" title="pickle.UnpicklingError"><code>UnpicklingError</code></a> by default.</p> <p>If defined, <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code>persistent_load()</code></a> should return the object specified by the persistent ID <em>pid</em>. If an invalid persistent ID is encountered, an <a class="reference internal" href="#pickle.UnpicklingError" title="pickle.UnpicklingError"><code>UnpicklingError</code></a> should be raised.</p> <p>See <a class="reference internal" href="#pickle-persistent"><span class="std std-ref">Persistence of External Objects</span></a> for details and examples of uses.</p> </dd>
</dl> <dl class="method"> <dt id="pickle.Unpickler.find_class">
<code>find_class(module, name)</code> </dt> <dd>
<p>Import <em>module</em> if necessary and return the object called <em>name</em> from it, where the <em>module</em> and <em>name</em> arguments are <a class="reference internal" href="../stdtypes/#str" title="str"><code>str</code></a> objects. Note, unlike its name suggests, <a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code>find_class()</code></a> is also used for finding functions.</p> <p>Subclasses may override this to gain control over what type of objects and how they can be loaded, potentially reducing security risks. Refer to <a class="reference internal" href="#pickle-restrict"><span class="std std-ref">Restricting Globals</span></a> for details.</p> </dd>
</dl> </dd>
</dl>   <h2 id="pickle-picklable">What can be pickled and unpickled?</h2> <p id="what-can-be-pickled-and-unpickled">The following types can be pickled:</p> <ul class="simple"> <li>
<code>None</code>, <code>True</code>, and <code>False</code>
</li> <li>integers, floating point numbers, complex numbers</li> <li>strings, bytes, bytearrays</li> <li>tuples, lists, sets, and dictionaries containing only picklable objects</li> <li>functions defined at the top level of a module (using <a class="reference internal" href="https://docs.python.org/3.7/reference/compound_stmts.html#def" target="_blank"><code>def</code></a>, not <a class="reference internal" href="https://docs.python.org/3.7/reference/expressions.html#lambda" target="_blank"><code>lambda</code></a>)</li> <li>built-in functions defined at the top level of a module</li> <li>classes that are defined at the top level of a module</li> <li>instances of such classes whose <a class="reference internal" href="../stdtypes/#object.__dict__" title="object.__dict__"><code>__dict__</code></a> or the result of calling <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> is picklable (see section <a class="reference internal" href="#pickle-inst"><span class="std std-ref">Pickling Class Instances</span></a> for details).</li> </ul> <p>Attempts to pickle unpicklable objects will raise the <a class="reference internal" href="#pickle.PicklingError" title="pickle.PicklingError"><code>PicklingError</code></a> exception; when this happens, an unspecified number of bytes may have already been written to the underlying file. Trying to pickle a highly recursive data structure may exceed the maximum recursion depth, a <a class="reference internal" href="../exceptions/#RecursionError" title="RecursionError"><code>RecursionError</code></a> will be raised in this case. You can carefully raise this limit with <a class="reference internal" href="../sys/#sys.setrecursionlimit" title="sys.setrecursionlimit"><code>sys.setrecursionlimit()</code></a>.</p> <p>Note that functions (built-in and user-defined) are pickled by “fully qualified” name reference, not by value. <a class="footnote-reference" href="#id7" id="id2">[2]</a> This means that only the function name is pickled, along with the name of the module the function is defined in. Neither the function’s code, nor any of its function attributes are pickled. Thus the defining module must be importable in the unpickling environment, and the module must contain the named object, otherwise an exception will be raised. <a class="footnote-reference" href="#id8" id="id3">[3]</a></p> <p>Similarly, classes are pickled by named reference, so the same restrictions in the unpickling environment apply. Note that none of the class’s code or data is pickled, so in the following example the class attribute <code>attr</code> is not restored in the unpickling environment:</p> <pre data-language="python">class Foo:
    attr = 'A class attribute'

picklestring = pickle.dumps(Foo)
</pre> <p>These restrictions are why picklable functions and classes must be defined in the top level of a module.</p> <p>Similarly, when class instances are pickled, their class’s code and data are not pickled along with them. Only the instance data are pickled. This is done on purpose, so you can fix bugs in a class or add methods to the class and still load objects that were created with an earlier version of the class. If you plan to have long-lived objects that will see many versions of a class, it may be worthwhile to put a version number in the objects so that suitable conversions can be made by the class’s <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a> method.</p>   <h2 id="pickle-inst">Pickling Class Instances</h2> <p id="pickling-class-instances">In this section, we describe the general mechanisms available to you to define, customize, and control how class instances are pickled and unpickled.</p> <p>In most cases, no additional code is needed to make instances picklable. By default, pickle will retrieve the class and the attributes of an instance via introspection. When a class instance is unpickled, its <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__init__" title="object.__init__" target="_blank"><code>__init__()</code></a> method is usually <em>not</em> invoked. The default behaviour first creates an uninitialized instance and then restores the saved attributes. The following code shows an implementation of this behaviour:</p> <pre data-language="python">def save(obj):
    return (obj.__class__, obj.__dict__)

def load(cls, attributes):
    obj = cls.__new__(cls)
    obj.__dict__.update(attributes)
    return obj
</pre> <p>Classes can alter the default behaviour by providing one or several special methods:</p> <dl class="method"> <dt id="object.__getnewargs_ex__">
<code>object.__getnewargs_ex__()</code> </dt> <dd>
<p>In protocols 2 and newer, classes that implements the <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code>__getnewargs_ex__()</code></a> method can dictate the values passed to the <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> method upon unpickling. The method must return a pair <code>(args, kwargs)</code> where <em>args</em> is a tuple of positional arguments and <em>kwargs</em> a dictionary of named arguments for constructing the object. Those will be passed to the <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> method upon unpickling.</p> <p>You should implement this method if the <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> method of your class requires keyword-only arguments. Otherwise, it is recommended for compatibility to implement <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a>.</p> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.6: </span><a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code>__getnewargs_ex__()</code></a> is now used in protocols 2 and 3.</p> </div> </dd>
</dl> <dl class="method"> <dt id="object.__getnewargs__">
<code>object.__getnewargs__()</code> </dt> <dd>
<p>This method serves a similar purpose as <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code>__getnewargs_ex__()</code></a>, but supports only positional arguments. It must return a tuple of arguments <code>args</code> which will be passed to the <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> method upon unpickling.</p> <p><a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a> will not be called if <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code>__getnewargs_ex__()</code></a> is defined.</p> <div class="versionchanged"> <p><span class="versionmodified">Changed in version 3.6: </span>Before Python 3.6, <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a> was called instead of <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code>__getnewargs_ex__()</code></a> in protocols 2 and 3.</p> </div> </dd>
</dl> <dl class="method"> <dt id="object.__getstate__">
<code>object.__getstate__()</code> </dt> <dd>
<p>Classes can further influence how their instances are pickled; if the class defines the method <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a>, it is called and the returned object is pickled as the contents for the instance, instead of the contents of the instance’s dictionary. If the <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> method is absent, the instance’s <a class="reference internal" href="../stdtypes/#object.__dict__" title="object.__dict__"><code>__dict__</code></a> is pickled as usual.</p> </dd>
</dl> <dl class="method"> <dt id="object.__setstate__">
<code>object.__setstate__(state)</code> </dt> <dd>
<p>Upon unpickling, if the class defines <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a>, it is called with the unpickled state. In that case, there is no requirement for the state object to be a dictionary. Otherwise, the pickled state must be a dictionary and its items are assigned to the new instance’s dictionary.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> returns a false value, the <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a> method will not be called upon unpickling.</p> </div> </dd>
</dl> <p>Refer to the section <a class="reference internal" href="#pickle-state"><span class="std std-ref">Handling Stateful Objects</span></a> for more information about how to use the methods <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> and <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">At unpickling time, some methods like <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__getattr__" title="object.__getattr__" target="_blank"><code>__getattr__()</code></a>, <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__getattribute__" title="object.__getattribute__" target="_blank"><code>__getattribute__()</code></a>, or <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__setattr__" title="object.__setattr__" target="_blank"><code>__setattr__()</code></a> may be called upon the instance. In case those methods rely on some internal invariant being true, the type should implement <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code>__getnewargs__()</code></a> or <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code>__getnewargs_ex__()</code></a> to establish such an invariant; otherwise, neither <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__new__" title="object.__new__" target="_blank"><code>__new__()</code></a> nor <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__init__" title="object.__init__" target="_blank"><code>__init__()</code></a> will be called.</p> </div> <p id="index-4">As we shall see, pickle does not use directly the methods described above. In fact, these methods are part of the copy protocol which implements the <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> special method. The copy protocol provides a unified interface for retrieving the data necessary for pickling and copying objects. <a class="footnote-reference" href="#id9" id="id4">[4]</a></p> <p>Although powerful, implementing <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> directly in your classes is error prone. For this reason, class designers should use the high-level interface (i.e., <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code>__getnewargs_ex__()</code></a>, <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> and <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a>) whenever possible. We will show, however, cases where using <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> is the only option or leads to more efficient pickling or both.</p> <dl class="method"> <dt id="object.__reduce__">
<code>object.__reduce__()</code> </dt> <dd>
<p>The interface is currently defined as follows. The <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> method takes no argument and shall return either a string or preferably a tuple (the returned object is often referred to as the “reduce value”).</p> <p>If a string is returned, the string should be interpreted as the name of a global variable. It should be the object’s local name relative to its module; the pickle module searches the module namespace to determine the object’s module. This behaviour is typically useful for singletons.</p> <p>When a tuple is returned, it must be between two and five items long. Optional items can either be omitted, or <code>None</code> can be provided as their value. The semantics of each item are in order:</p> <ul class="simple"> <li>A callable object that will be called to create the initial version of the object.</li> <li>A tuple of arguments for the callable object. An empty tuple must be given if the callable does not accept any argument.</li> <li>Optionally, the object’s state, which will be passed to the object’s <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a> method as previously described. If the object has no such method then, the value must be a dictionary and it will be added to the object’s <a class="reference internal" href="../stdtypes/#object.__dict__" title="object.__dict__"><code>__dict__</code></a> attribute.</li> <li>Optionally, an iterator (and not a sequence) yielding successive items. These items will be appended to the object either using <code>obj.append(item)</code> or, in batch, using <code>obj.extend(list_of_items)</code>. This is primarily used for list subclasses, but may be used by other classes as long as they have <code>append()</code> and <code>extend()</code> methods with the appropriate signature. (Whether <code>append()</code> or <code>extend()</code> is used depends on which pickle protocol version is used as well as the number of items to append, so both must be supported.)</li> <li>Optionally, an iterator (not a sequence) yielding successive key-value pairs. These items will be stored to the object using <code>obj[key] =
value</code>. This is primarily used for dictionary subclasses, but may be used by other classes as long as they implement <a class="reference internal" href="https://docs.python.org/3.7/reference/datamodel.html#object.__setitem__" title="object.__setitem__" target="_blank"><code>__setitem__()</code></a>.</li> </ul> </dd>
</dl> <dl class="method"> <dt id="object.__reduce_ex__">
<code>object.__reduce_ex__(protocol)</code> </dt> <dd>
<p>Alternatively, a <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code>__reduce_ex__()</code></a> method may be defined. The only difference is this method should take a single integer argument, the protocol version. When defined, pickle will prefer it over the <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> method. In addition, <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code>__reduce__()</code></a> automatically becomes a synonym for the extended version. The main use for this method is to provide backwards-compatible reduce values for older Python releases.</p> </dd>
</dl>  <h3 id="pickle-persistent">Persistence of External Objects</h3> <p id="persistence-of-external-objects">For the benefit of object persistence, the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module supports the notion of a reference to an object outside the pickled data stream. Such objects are referenced by a persistent ID, which should be either a string of alphanumeric characters (for protocol 0) <a class="footnote-reference" href="#id10" id="id5">[5]</a> or just an arbitrary object (for any newer protocol).</p> <p>The resolution of such persistent IDs is not defined by the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module; it will delegate this resolution to the user defined methods on the pickler and unpickler, <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code>persistent_id()</code></a> and <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code>persistent_load()</code></a> respectively.</p> <p>To pickle objects that have an external persistent id, the pickler must have a custom <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code>persistent_id()</code></a> method that takes an object as an argument and returns either <code>None</code> or the persistent id for that object. When <code>None</code> is returned, the pickler simply pickles the object as normal. When a persistent ID string is returned, the pickler will pickle that object, along with a marker so that the unpickler will recognize it as a persistent ID.</p> <p>To unpickle external objects, the unpickler must have a custom <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code>persistent_load()</code></a> method that takes a persistent ID object and returns the referenced object.</p> <p>Here is a comprehensive example presenting how persistent ID can be used to pickle external objects by reference.</p> <pre data-language="python"># Simple example presenting how persistent ID can be used to pickle
# external objects by reference.

import pickle
import sqlite3
from collections import namedtuple

# Simple class representing a record in our database.
MemoRecord = namedtuple("MemoRecord", "key, task")

class DBPickler(pickle.Pickler):

    def persistent_id(self, obj):
        # Instead of pickling MemoRecord as a regular class instance, we emit a
        # persistent ID.
        if isinstance(obj, MemoRecord):
            # Here, our persistent ID is simply a tuple, containing a tag and a
            # key, which refers to a specific record in the database.
            return ("MemoRecord", obj.key)
        else:
            # If obj does not have a persistent ID, return None. This means obj
            # needs to be pickled as usual.
            return None


class DBUnpickler(pickle.Unpickler):

    def __init__(self, file, connection):
        super().__init__(file)
        self.connection = connection

    def persistent_load(self, pid):
        # This method is invoked whenever a persistent ID is encountered.
        # Here, pid is the tuple returned by DBPickler.
        cursor = self.connection.cursor()
        type_tag, key_id = pid
        if type_tag == "MemoRecord":
            # Fetch the referenced record from the database and return it.
            cursor.execute("SELECT * FROM memos WHERE key=?", (str(key_id),))
            key, task = cursor.fetchone()
            return MemoRecord(key, task)
        else:
            # Always raises an error if you cannot return the correct object.
            # Otherwise, the unpickler will think None is the object referenced
            # by the persistent ID.
            raise pickle.UnpicklingError("unsupported persistent object")


def main():
    import io
    import pprint

    # Initialize and populate our database.
    conn = sqlite3.connect(":memory:")
    cursor = conn.cursor()
    cursor.execute("CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)")
    tasks = (
        'give food to fish',
        'prepare group meeting',
        'fight with a zebra',
        )
    for task in tasks:
        cursor.execute("INSERT INTO memos VALUES(NULL, ?)", (task,))

    # Fetch the records to be pickled.
    cursor.execute("SELECT * FROM memos")
    memos = [MemoRecord(key, task) for key, task in cursor]
    # Save the records using our custom DBPickler.
    file = io.BytesIO()
    DBPickler(file).dump(memos)

    print("Pickled records:")
    pprint.pprint(memos)

    # Update a record, just for good measure.
    cursor.execute("UPDATE memos SET task='learn italian' WHERE key=1")

    # Load the records from the pickle data stream.
    file.seek(0)
    memos = DBUnpickler(file, conn).load()

    print("Unpickled records:")
    pprint.pprint(memos)


if __name__ == '__main__':
    main()
</pre>   <h3 id="pickle-dispatch">Dispatch Tables</h3> <p id="dispatch-tables">If one wants to customize pickling of some classes without disturbing any other code which depends on pickling, then one can create a pickler with a private dispatch table.</p> <p>The global dispatch table managed by the <a class="reference internal" href="../copyreg/#module-copyreg" title="copyreg: Register pickle support functions."><code>copyreg</code></a> module is available as <code>copyreg.dispatch_table</code>. Therefore, one may choose to use a modified copy of <code>copyreg.dispatch_table</code> as a private dispatch table.</p> <p>For example</p> <pre data-language="python">f = io.BytesIO()
p = pickle.Pickler(f)
p.dispatch_table = copyreg.dispatch_table.copy()
p.dispatch_table[SomeClass] = reduce_SomeClass
</pre> <p>creates an instance of <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code>pickle.Pickler</code></a> with a private dispatch table which handles the <code>SomeClass</code> class specially. Alternatively, the code</p> <pre data-language="python">class MyPickler(pickle.Pickler):
    dispatch_table = copyreg.dispatch_table.copy()
    dispatch_table[SomeClass] = reduce_SomeClass
f = io.BytesIO()
p = MyPickler(f)
</pre> <p>does the same, but all instances of <code>MyPickler</code> will by default share the same dispatch table. The equivalent code using the <a class="reference internal" href="../copyreg/#module-copyreg" title="copyreg: Register pickle support functions."><code>copyreg</code></a> module is</p> <pre data-language="python">copyreg.pickle(SomeClass, reduce_SomeClass)
f = io.BytesIO()
p = pickle.Pickler(f)
</pre>   <h3 id="pickle-state">Handling Stateful Objects</h3> <p id="handling-stateful-objects">Here’s an example that shows how to modify pickling behavior for a class. The <code>TextReader</code> class opens a text file, and returns the line number and line contents each time its <code>readline()</code> method is called. If a <code>TextReader</code> instance is pickled, all attributes <em>except</em> the file object member are saved. When the instance is unpickled, the file is reopened, and reading resumes from the last location. The <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code>__setstate__()</code></a> and <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code>__getstate__()</code></a> methods are used to implement this behavior.</p> <pre data-language="python">class TextReader:
    """Print and number lines in a text file."""

    def __init__(self, filename):
        self.filename = filename
        self.file = open(filename)
        self.lineno = 0

    def readline(self):
        self.lineno += 1
        line = self.file.readline()
        if not line:
            return None
        if line.endswith('\n'):
            line = line[:-1]
        return "%i: %s" % (self.lineno, line)

    def __getstate__(self):
        # Copy the object's state from self.__dict__ which contains
        # all our instance attributes. Always use the dict.copy()
        # method to avoid modifying the original state.
        state = self.__dict__.copy()
        # Remove the unpicklable entries.
        del state['file']
        return state

    def __setstate__(self, state):
        # Restore instance attributes (i.e., filename and lineno).
        self.__dict__.update(state)
        # Restore the previously opened file's state. To do so, we need to
        # reopen it and read from it until the line count is restored.
        file = open(self.filename)
        for _ in range(self.lineno):
            file.readline()
        # Finally, save the file.
        self.file = file
</pre> <p>A sample usage might be something like this:</p> <pre data-language="python">&gt;&gt;&gt; reader = TextReader("hello.txt")
&gt;&gt;&gt; reader.readline()
'1: Hello world!'
&gt;&gt;&gt; reader.readline()
'2: I am line number two.'
&gt;&gt;&gt; new_reader = pickle.loads(pickle.dumps(reader))
&gt;&gt;&gt; new_reader.readline()
'3: Goodbye!'
</pre>    <h2 id="pickle-restrict">Restricting Globals</h2> <p id="restricting-globals">By default, unpickling will import any class or function that it finds in the pickle data. For many applications, this behaviour is unacceptable as it permits the unpickler to import and invoke arbitrary code. Just consider what this hand-crafted pickle data stream does when loaded:</p> <pre data-language="python">&gt;&gt;&gt; import pickle
&gt;&gt;&gt; pickle.loads(b"cos\nsystem\n(S'echo hello world'\ntR.")
hello world
0
</pre> <p>In this example, the unpickler imports the <a class="reference internal" href="../os/#os.system" title="os.system"><code>os.system()</code></a> function and then apply the string argument “echo hello world”. Although this example is inoffensive, it is not difficult to imagine one that could damage your system.</p> <p>For this reason, you may want to control what gets unpickled by customizing <a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code>Unpickler.find_class()</code></a>. Unlike its name suggests, <a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code>Unpickler.find_class()</code></a> is called whenever a global (i.e., a class or a function) is requested. Thus it is possible to either completely forbid globals or restrict them to a safe subset.</p> <p>Here is an example of an unpickler allowing only few safe classes from the <a class="reference internal" href="../builtins/#module-builtins" title="builtins: The module that provides the built-in namespace."><code>builtins</code></a> module to be loaded:</p> <pre data-language="python">import builtins
import io
import pickle

safe_builtins = {
    'range',
    'complex',
    'set',
    'frozenset',
    'slice',
}

class RestrictedUnpickler(pickle.Unpickler):

    def find_class(self, module, name):
        # Only allow safe classes from builtins.
        if module == "builtins" and name in safe_builtins:
            return getattr(builtins, name)
        # Forbid everything else.
        raise pickle.UnpicklingError("global '%s.%s' is forbidden" %
                                     (module, name))

def restricted_loads(s):
    """Helper function analogous to pickle.loads()."""
    return RestrictedUnpickler(io.BytesIO(s)).load()
</pre> <p>A sample usage of our unpickler working has intended:</p> <pre data-language="python">&gt;&gt;&gt; restricted_loads(pickle.dumps([1, 2, range(15)]))
[1, 2, range(0, 15)]
&gt;&gt;&gt; restricted_loads(b"cos\nsystem\n(S'echo hello world'\ntR.")
Traceback (most recent call last):
  ...
pickle.UnpicklingError: global 'os.system' is forbidden
&gt;&gt;&gt; restricted_loads(b'cbuiltins\neval\n'
...                  b'(S\'getattr(__import__("os"), "system")'
...                  b'("echo hello world")\'\ntR.')
Traceback (most recent call last):
  ...
pickle.UnpicklingError: global 'builtins.eval' is forbidden
</pre> <p>As our examples shows, you have to be careful with what you allow to be unpickled. Therefore if security is a concern, you may want to consider alternatives such as the marshalling API in <a class="reference internal" href="../xmlrpc.client/#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code>xmlrpc.client</code></a> or third-party solutions.</p>   <h2 id="performance">Performance</h2> <p>Recent versions of the pickle protocol (from protocol 2 and upwards) feature efficient binary encodings for several common features and built-in types. Also, the <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a> module has a transparent optimizer written in C.</p>   <h2 id="pickle-example">Examples</h2> <p id="examples">For the simplest code, use the <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code>dump()</code></a> and <a class="reference internal" href="#pickle.load" title="pickle.load"><code>load()</code></a> functions.</p> <pre data-language="python">import pickle

# An arbitrary collection of objects supported by pickle.
data = {
    'a': [1, 2.0, 3, 4+6j],
    'b': ("character string", b"byte string"),
    'c': {None, True, False}
}

with open('data.pickle', 'wb') as f:
    # Pickle the 'data' dictionary using the highest protocol available.
    pickle.dump(data, f, pickle.HIGHEST_PROTOCOL)
</pre> <p>The following example reads the resulting pickled data.</p> <pre data-language="python">import pickle

with open('data.pickle', 'rb') as f:
    # The protocol version used is detected automatically, so we do not
    # have to specify it.
    data = pickle.load(f)
</pre> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <dl class="last docutils"> <dt>
<code>Module</code> <a class="reference internal" href="../copyreg/#module-copyreg" title="copyreg: Register pickle support functions."><code>copyreg</code></a>
</dt> <dd>Pickle interface constructor registration for extension types.</dd> <dt>
<code>Module</code> <a class="reference internal" href="../pickletools/#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code>pickletools</code></a>
</dt> <dd>Tools for working with and analyzing pickled data.</dd> <dt>
<code>Module</code> <a class="reference internal" href="../shelve/#module-shelve" title="shelve: Python object persistence."><code>shelve</code></a>
</dt> <dd>Indexed databases of objects; uses <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code>pickle</code></a>.</dd> <dt>
<code>Module</code> <a class="reference internal" href="../copy/#module-copy" title="copy: Shallow and deep copy operations."><code>copy</code></a>
</dt> <dd>Shallow and deep object copying.</dd> <dt>
<code>Module</code> <a class="reference internal" href="../marshal/#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a>
</dt> <dd>High-performance serialization of built-in types.</dd> </dl> </div> <h4 class="rubric">Footnotes</h4> <table class="docutils footnote" frame="void" id="id6" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[1]</a></td>
<td>Don’t confuse this with the <a class="reference internal" href="../marshal/#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code>marshal</code></a> module</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id7" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id2">[2]</a></td>
<td>This is why <a class="reference internal" href="https://docs.python.org/3.7/reference/expressions.html#lambda" target="_blank"><code>lambda</code></a> functions cannot be pickled: all <a class="reference internal" href="https://docs.python.org/3.7/reference/expressions.html#lambda" target="_blank"><code>lambda</code></a> functions share the same name: <code>&lt;lambda&gt;</code>.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id8" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id3">[3]</a></td>
<td>The exception raised will likely be an <a class="reference internal" href="../exceptions/#ImportError" title="ImportError"><code>ImportError</code></a> or an <a class="reference internal" href="../exceptions/#AttributeError" title="AttributeError"><code>AttributeError</code></a> but it could be something else.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id9" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id4">[4]</a></td>
<td>The <a class="reference internal" href="../copy/#module-copy" title="copy: Shallow and deep copy operations."><code>copy</code></a> module uses this protocol for shallow and deep copying operations.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id10" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id5">[5]</a></td>
<td>The limitation on alphanumeric characters is due to the fact the persistent IDs, in protocol 0, are delimited by the newline character. Therefore if any kind of newline characters occurs in persistent IDs, the resulting pickle will become unreadable.</td>
</tr>  </table>
<div class="_attribution">
  <p class="_attribution-p">
    © 2001–2018 Python Software Foundation<br>Licensed under the PSF License.<br>
    <a href="https://docs.python.org/3.7/library/pickle.html" class="_attribution-link" target="_blank">https://docs.python.org/3.7/library/pickle.html</a>
  </p>
</div>

				<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 文档结尾内嵌 -->
<ins class="adsbygoogle"
    style="display:block"
    data-ad-client="ca-pub-2572770204602497"
    data-ad-slot="5446239318"
    data-ad-format="auto"
    data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
			</div>
		</div>
	</section>

	</div>
	<svg style="display:none">
		<symbol id="icon-dir"><svg viewBox="0 0 20 20"><path d="M15 10c0 .3-.305.515-.305.515l-8.56 5.303c-.625.41-1.135.106-1.135-.67V4.853c0-.777.51-1.078 1.135-.67l8.56 5.305S15 9.702 15 10z"/></svg></symbol>
	  </svg>
</body>
</html>
